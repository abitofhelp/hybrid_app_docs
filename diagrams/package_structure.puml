@startuml package_structure
!theme plain
skinparam componentStyle rectangle

title Package Structure\nActual Packages in Each Layer

frame "Bootstrap Layer" #FFEBCD {
  component "Bootstrap.CLI" as BootstrapCLI
  note right of BootstrapCLI
    **Composition Root**
    - Wires all dependencies
    - Generic instantiation
    - Application entry point

    ```ada
    package Greet_UC is new
      Application.Usecase.Greet
        (Writer => Console_Writer.Write);
    package Greet_Cmd is new
      Presentation.Adapter.CLI.Command.Greet
        (Execute_Greet_UseCase => Greet_UC.Execute);
    ```
  end note
}

frame "Presentation Layer" #FFE4E1 {
  component "Presentation.Adapter.CLI.Command.Greet" as PresentationGreet
  note right of PresentationGreet
    **Depends on:**
    - Application.Command
    - Application.Port.Outbound.Writer
    - **Application.Error** ✅

    **Cannot access:**
    ❌ Domain.* packages

    **Generic over Execute_Greet_UseCase:**
    with function Execute_Greet_UseCase (...) return Result
  end note
}

frame "Infrastructure Layer" #E6F3FF {
  component "Infrastructure.Adapter.Console_Writer" as InfraConsole
  note right of InfraConsole
    **Depends on:**
    - Application.Port.Outbound.Writer
    - Domain.Error (direct) ✅
    - Domain.Unit

    **Implements Writer Port:**
    Console_Writer.Write(Message)
  end note
}

frame "Application Layer" #E8F5E9 {
  component "Application.Error" as AppError #FFFF99
  component "Application.Command" as AppCommand
  component "Application.Usecase" as AppUsecase
  component "Application.Port.Outbound.Writer" as AppPort

  note right of AppError
    **Re-exports Domain.Error**
    For Presentation layer use

    ```ada
    with Domain.Error;
    package Application.Error is
       subtype Error_Type is Domain.Error.Error_Type;
       subtype Error_Kind is Domain.Error.Error_Kind;
       Validation_Error : constant Error_Kind
         := Domain.Error.Validation_Error;
    end Application.Error;
    ```
  end note
}

frame "Domain Layer" #FFF9E6 {
  component "Domain.Error" as DomainError
  component "Domain.Result.Generic_Result" as DomainResult
  component "Domain.Person" as DomainPerson

  note right of DomainError
    **Zero external deps**
    Pure domain logic
    Canonical error types
  end note
}

' Dependencies (center-seeking - all point inbound)
PresentationGreet -down-> AppCommand : uses DTO
PresentationGreet -down-> AppUsecase : uses Execute
PresentationGreet -down-> AppError : uses ✅

InfraConsole -down-> AppPort : implements Port
InfraConsole -down-> DomainError : uses ✅

AppCommand -down-> DomainPerson : uses
AppUsecase -down-> DomainPerson : validates
AppPort -down-> DomainResult : uses
AppError -down-> DomainError : re-exports

' Forbidden dependency (shown as violation)
PresentationGreet .right.> DomainError #red : ❌ FORBIDDEN\nNo transitive access

legend bottom
  **Package Naming Convention**
  ════════════════════════════════════
  All packages use hierarchical paths:
  • Parent.Child.Grandchild pattern
  • Underscore_Pascal_Case
  • GPR project per layer

  **Example:**
  • Package: Domain.Person
  • File: domain-person.ads/adb
  • Type: Person

  **Dependency Rules**
  ════════════════════════════════════
  ✅ Presentation → Application.* packages
  ✅ Infrastructure → Application.* + Domain.* packages
  ✅ Application → Domain.* packages
  ❌ Presentation → Domain.* packages (forbidden!)

  **Static Dispatch with Generics**
  ════════════════════════════════════
  • Use_Case with function Console_Write - generic over writer
  • Command with function Execute - generic over use case
  • Concrete functions bound at instantiation
  • Zero runtime overhead (no dispatching)
endlegend

@enduml
